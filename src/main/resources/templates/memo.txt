1. JPA를 사용하는 이유
- 단순한 CRUD의 무한 반복 해결
- SQL에 의존적이지 않는 객체 중심의 개발
- 패러다임의 불일치 해결
- 관계형DB와 달리 엔티티의 신뢰도가 높고, 자유로운 그래프 탐색이 가능
- 같은 트랜잭션 안에서는 같은 엔티티를 반환
	* 한 번 조회한 SQL을 두 번째부터의 같은 객체의 조회는 이미 조회한 데이터의 캐싱작용으로 SQL의 조회가 필요 없이 캐시(메모리)에 있는 데이터를 읽어온다.
	* 같은 트랜잭션 안에서 같은 엔티티의 조회가 여러번 이루질 때 SQL은 한 번만 실행한다.

2. 즉시로딩과 지연로딩
- 지연로딩: LAZY로 설정된 객체는 해당 객체의 초기화 시점(조회하는 시점)에 SQL을 실행한다.
- 즉시로딩: EAGER로 설정된 객체는 해당 객체가 필요로하지 않는 시점에도 SQL을 실행하여 가져온다.
	* 문제점: 필요없는 데이터도 호출하기 때문에 성능의 문제가 있을 수 있다.

3. JPA 내부 동작방식 이해
- Persistence(시작) -> EntityManagerFactory 실행 -> EntityManager 생성
- JPA의 모든 데이터 변경은 트랜잭션 안에서 이루어져야함
- 고객 요청시 EntityManagerFactory에서 EntityManger를 생성함

3-1. 영속성 컨텍스트
- 객체를 영구저장하는 환경
- 내부에 1차 캐시를 가지고 있음
- EntityManger를 통해서 영속성 컨텍스트(persistenceContext)에 접근함

3-2 버퍼링(persist시점에 SQL의 호출이 발생하지 않는 이유)
- 설정한 batch size만큼 영속성 컨텍스트를 모았다가 커밋시점에 SQL이 이루어진다.

3-3 변경감지(dirty checking)
- 1차캐시 안에 저장되어 있는 값과 스냅샷(값을 처음 읽어온 시점)을 비교
- flush 시점에 엔티티와 스냅샷의 값을 비교
- 변경된 값이 있으면 sql저장소에 값을 저장 후 DB에 커밋한다.

3-4 플러시
- 영속성 컨텍스트의 변경내용을 DB에 동기화
- 영속성 컨텍스트를 비우지 않음
- 트랜잭션이 끝나기 전(커밋 전)에만 동기화하면 됨

3-5 준영속성 컨텍스트
- persist이후 detach, clear, close등 함수를 사용하여 DB까지 가지 않고 1차 캐시에서만 관리할 수 있는 상태

4. 엔티티
- 기본 생성자 필수(파라미터가 없는 public, protected 생성자) - 스펙상 설정
- nullable을 false로 설정 시 해당 컬럼에 대한 not null 설정이 됨

4-1 @Enumerated
- ordinal : 순서를 DB에 저장(권장x)
	* Enum에 값을 추가하게 되면 DB에 저장되어 있는 순서와 상과없이 순서가 재배치됨
	* 순서가 재배치되면서 실제 값과 DB의 순서와 일치하지 않는 현상이 발생
- string: 이름을 DB에 저장

4-2 기본키매핑
- generatedValue
	* identity : 영속성 컨텍스트에서 시퀀스가 생성되는 것이 아닌 DB에서 생성이됨
		따라서 DB에 들어가기 전까지 1차 캐시에는 시퀀스를 알 수 없음
		또한 persist시점에 query를 실행함

5. 연관관계

**중요**
5-1 양방향 연관관계와 연관관계 주인
- mappedBy를 설정하여 연관관계의 주인을 정한다.
- mappedBy로 설정된 객체는 조회는 가능하지만 값의 수정은 불가능하다.
- 값의 수정은 연관관계의 주인인 엔티티에서만 할 수 있다.
- 연관관계의 주인은 외래키가 있는 엔티티를 주인으로 정한다.

5-2 연관관계 주인을 정하는 기준
- 외래키가 존재하는 테이블이 N, 존재하지 않는 테이블이 1로 기준을 정한다.
- 외래키가 존재하는 테이블이 연관관계의 주인으로 정한다.

6. 프록시
- getReference() 메서드를 사용하여 가짜 엔티티 객체 조회
	* 실제 엔티티와 모양새는 똑같지만 텅빈 상태라고 볼 수 있다.
- 실제 객체의 참조(target)를 보관한다.

6-1 프록시 객체의 초기화 루틴
- 클라이언트 요청 -> 프록시에서 데이터 확인 -> 영속성 컨텍스트를 통해 DB에 데이터 요청
 -> DB에서 데이터 조회 -> 실제 엔티티 생성 -> 프록시에서 실제 엔티티에 데이터 요청(target)

6-2 프록시 특징
- 처음 사용 시 딱 한 번만 초기화함
- 초기화 할 때 프록시 객체가 실제 엔티티로 변경되는 것이 아닌 접근이 가능한 것이다.
- 프록시 객체는 실제 엔티티를 상속 받음, 타입 체크시 instance of 사용
- 영속성 컨텍스트에 찾는 엔티티가 있으면 프록시 초기화 시 엔티티를 반환한다.

7. 값 타입

7-1 Embeddable vs MappedSuperclass (위임과 상속의 차이)
- 위임: 위임 관계에 있는 클래스의 인스턴스를 가지고 있다. 동적인 관계로 런타임 시간 동안 관계까지 변경될 수 있다.
- 상속: 상속 관계에 있는 클래스를 가지고 있다. 정적인 관계로 컴파일 시간에 모든 관계가 정해진다.

8. fetch join
- 1대다 조인인 경우 기준이 다를 기준으로 페이징을 처리하여 메인 테이블에 대하여 처리가 불가능함
    -> 페치조인 시 firstResult와 maxResults를 처리하지 못하여 모든 데이터를 메모리에 저장 후 페이징 처리를 진행
- 1대다에 대한 페치조인은 하나만 사용 가능함, 두 개 이상 사용하는 경우 데이터 뻥튀기가 심하여 부정확한 데이터가 조회됨.